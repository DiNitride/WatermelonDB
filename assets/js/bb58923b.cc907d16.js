"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[9749],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),p=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),c=p(n),u=a,h=c["".concat(l,".").concat(u)]||c[u]||d[u]||r;return n?o.createElement(h,s(s({ref:t},m),{},{components:n})):o.createElement(h,s({ref:t},m))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,s=new Array(r);s[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[c]="string"==typeof e?e:a,s[1]=i;for(var p=2;p<r;p++)s[p]=n[p];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1890:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>r,metadata:()=>i,toc:()=>p});var o=n(7462),a=(n(7294),n(3905));const r={},s="Connecting Components",i={unversionedId:"docs/Components",id:"docs/Components",title:"Connecting Components",description:"After you define some Models, it's time to connect Watermelon to your app's interface. We're using React in this guide, however WatermelonDB can be used with any UI framework.",source:"@site/docs/docs/Components.md",sourceDirName:"docs",slug:"/docs/Components",permalink:"/docs/Components",draft:!1,editUrl:"https://github.com/nozbe/WatermelonDB/edit/master/docs-website/docs/docs/Components.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Create, Read, Update, Delete",permalink:"/docs/CRUD"},next:{title:"Querying",permalink:"/docs/Query"}},l={},p=[{value:"Reactive components",id:"reactive-components",level:2},{value:"Reactive lists",id:"reactive-lists",level:3},{value:"Reactive relations",id:"reactive-relations",level:3},{value:"Reactive counters",id:"reactive-counters",level:3},{value:"Hey, what about React Hooks?",id:"hey-what-about-react-hooks",level:2},{value:"Understanding <code>withObservables</code>",id:"understanding-withobservables",level:2},{value:"Advanced",id:"advanced",level:2},{value:"Advanced: observing sorted lists",id:"advanced-observing-sorted-lists",level:3},{value:"Advanced: observing 2nd level relations",id:"advanced-observing-2nd-level-relations",level:3},{value:"Alternative method of observing 2nd level relations",id:"alternative-method-of-observing-2nd-level-relations",level:4},{value:"2nd level optional relations",id:"2nd-level-optional-relations",level:4},{value:"Database Provider",id:"database-provider",level:2},{value:"<code>useDatabase</code>",id:"usedatabase",level:3},{value:"Next steps",id:"next-steps",level:2}],m={toc:p};function c(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"connecting-components"},"Connecting Components"),(0,a.kt)("p",null,"After you ",(0,a.kt)("a",{parentName:"p",href:"/docs/Model"},"define some Models"),", it's time to connect Watermelon to your app's interface. We're using React in this guide, however WatermelonDB can be used with any UI framework."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Note:")," If you're not familiar with higher-order components, read ",(0,a.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/higher-order-components.html"},"React documentation"),", check out ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/acdlite/recompose"},(0,a.kt)("inlineCode",{parentName:"a"},"recompose")),"\u2026 or just read the examples below to see it in practice!"),(0,a.kt)("h2",{id:"reactive-components"},"Reactive components"),(0,a.kt)("p",null,"Here's a very simple React component rendering a ",(0,a.kt)("inlineCode",{parentName:"p"},"Comment")," record:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"const Comment = ({ comment }) => (\n  <div>\n    <p>{comment.body}</p>\n  </div>\n)\n")),(0,a.kt)("p",null,"Now we can fetch a comment: ",(0,a.kt)("inlineCode",{parentName:"p"},"const comment = await commentsCollection.find(id)")," and then render it: ",(0,a.kt)("inlineCode",{parentName:"p"},"<Comment comment={comment} />"),". The only problem is that this is ",(0,a.kt)("strong",{parentName:"p"},"not reactive"),". If the Comment is updated or deleted, the component will not re-render to reflect the changes. (Unless an update is forced manually or the parent component re-renders)."),(0,a.kt)("p",null,"Let's enhance the component to make it ",(0,a.kt)("em",{parentName:"p"},"observe")," the ",(0,a.kt)("inlineCode",{parentName:"p"},"Comment")," automatically:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"import withObservables from '@nozbe/with-observables'\nconst enhance = withObservables(['comment'], ({ comment }) => ({\n  comment // shortcut syntax for `comment: comment.observe()`\n}))\nconst EnhancedComment = enhance(Comment)\nexport default EnhancedComment\n")),(0,a.kt)("p",null,"Now, if we render ",(0,a.kt)("inlineCode",{parentName:"p"},"<EnhancedComment comment={comment} />"),", it ",(0,a.kt)("strong",{parentName:"p"},"will")," update every time the comment changes."),(0,a.kt)("h3",{id:"reactive-lists"},"Reactive lists"),(0,a.kt)("p",null,"Let's render the whole ",(0,a.kt)("inlineCode",{parentName:"p"},"Post")," with comments:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"import withObservables from '@nozbe/with-observables'\nimport EnhancedComment from 'components/Comment'\n\nconst Post = ({ post, comments }) => (\n  <article>\n    <h1>{post.name}</h1>\n    <p>{post.body}</p>\n    <h2>Comments</h2>\n    {comments.map(comment =>\n      <EnhancedComment key={comment.id} comment={comment} />\n    )}\n  </article>\n)\n\nconst enhance = withObservables(['post'], ({ post }) => ({\n  post,\n  comments: post.comments, // Shortcut syntax for `post.comments.observe()`\n}))\n\nconst EnhancedPost = enhance(Post)\nexport default EnhancedPost\n")),(0,a.kt)("p",null,"Notice a couple of things:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"We're starting with a simple non-reactive ",(0,a.kt)("inlineCode",{parentName:"p"},"Post")," component")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Like before, we enhance it by observing the ",(0,a.kt)("inlineCode",{parentName:"p"},"Post"),". If the post name or body changes, it will re-render.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"To access comments, we fetch them from the database and observe using ",(0,a.kt)("inlineCode",{parentName:"p"},"post.comments.observe()")," and inject a new prop ",(0,a.kt)("inlineCode",{parentName:"p"},"comments"),". (",(0,a.kt)("inlineCode",{parentName:"p"},"post.comments")," is a Query created using ",(0,a.kt)("inlineCode",{parentName:"p"},"@children"),")."),(0,a.kt)("p",{parentName:"li"},"Note that we can skip ",(0,a.kt)("inlineCode",{parentName:"p"},".observe()")," and just pass ",(0,a.kt)("inlineCode",{parentName:"p"},"post.comments")," for convenience \u2014 ",(0,a.kt)("inlineCode",{parentName:"p"},"withObservables")," will call observe for us")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"By ",(0,a.kt)("strong",{parentName:"p"},"observing the Query"),", the ",(0,a.kt)("inlineCode",{parentName:"p"},"<Post>")," component will re-render if a comment is created or deleted")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"However, observing the comments Query will not re-render ",(0,a.kt)("inlineCode",{parentName:"p"},"<Post>")," if a comment is ",(0,a.kt)("em",{parentName:"p"},"updated")," \u2014 we render the ",(0,a.kt)("inlineCode",{parentName:"p"},"<EnhancedComment>")," so that ",(0,a.kt)("em",{parentName:"p"},"it")," observes the comment and re-renders if necessary."))),(0,a.kt)("h3",{id:"reactive-relations"},"Reactive relations"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"<Comment>")," component we made previously only renders the body of the comment but doesn't say who posted it."),(0,a.kt)("p",null,"Assume the ",(0,a.kt)("inlineCode",{parentName:"p"},"Comment")," model has a ",(0,a.kt)("inlineCode",{parentName:"p"},"@relation('users', 'author_id') author")," field. Let's render it:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"const Comment = ({ comment, author }) => (\n  <div>\n    <p>{comment.body} \u2014 by {author.name}</p>\n  </div>\n)\n\nconst enhance = withObservables(['comment'], ({ comment }) => ({\n  comment,\n  author: comment.author, // shortcut syntax for `comment.author.observe()`\n}))\nconst EnhancedComment = enhance(Comment)\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"comment.author")," is a ",(0,a.kt)("a",{parentName:"p",href:"/docs/Relation"},"Relation object"),", and we can call ",(0,a.kt)("inlineCode",{parentName:"p"},".observe()")," on it to fetch the ",(0,a.kt)("inlineCode",{parentName:"p"},"User")," and then observe changes to it. If author's name changes, the component will re-render."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Note")," again that we can also pass ",(0,a.kt)("inlineCode",{parentName:"p"},"Relation")," objects directly for convenience, skipping ",(0,a.kt)("inlineCode",{parentName:"p"},".observe()")),(0,a.kt)("h3",{id:"reactive-counters"},"Reactive counters"),(0,a.kt)("p",null,"Let's make a ",(0,a.kt)("inlineCode",{parentName:"p"},"<PostExcerpt>")," component to display on a ",(0,a.kt)("em",{parentName:"p"},"list")," of Posts, with only a brief summary of the contents and only the number of comments it has:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"const PostExcerpt = ({ post, commentCount }) => (\n  <div>\n    <h1>{post.name}</h1>\n    <p>{getExcerpt(post.body)}</p>\n    <span>{commentCount} comments</span>\n  </div>\n)\n\nconst enhance = withObservables(['post'], ({ post }) => ({\n  post,\n  commentCount: post.comments.observeCount()\n}))\n\nconst EnhancedPostExcerpt = enhance(PostExcerpt)\n")),(0,a.kt)("p",null,"This is very similar to normal ",(0,a.kt)("inlineCode",{parentName:"p"},"<Post>"),". We take the ",(0,a.kt)("inlineCode",{parentName:"p"},"Query")," for post's comments, but instead of observing the ",(0,a.kt)("em",{parentName:"p"},"list")," of comments, we call ",(0,a.kt)("inlineCode",{parentName:"p"},"observeCount()"),". This is far more efficient. And as always, if a new comment is posted, or one is deleted, the component will re-render with the updated count."),(0,a.kt)("h2",{id:"hey-what-about-react-hooks"},"Hey, what about React Hooks?"),(0,a.kt)("p",null,"We get it \u2014 HOCs are so 2017, and Hooks are the future! And we agree."),(0,a.kt)("p",null,"However, Hooks are not compatible with WatermelonDB's asynchronous API. You ",(0,a.kt)("em",{parentName:"p"},"could")," use alternative open-source Hooks for Rx Observables, however we don't recommend that. They won't work correctly in all cases and won't be as optimized for performance with WatermelonDB as ",(0,a.kt)("inlineCode",{parentName:"p"},"withObservables"),". In the future, once Concurrent React is fully developed and published, WatermelonDB will have official hooks."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("a",{parentName:"strong",href:"https://github.com/Nozbe/withObservables/issues/16"},"See discussion about official ",(0,a.kt)("inlineCode",{parentName:"a"},"useObservables")," Hook"))),(0,a.kt)("h2",{id:"understanding-withobservables"},"Understanding ",(0,a.kt)("inlineCode",{parentName:"h2"},"withObservables")),(0,a.kt)("p",null,"Let's unpack this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"withObservables(['post'], ({ post }) => ({\n  post: post.observe(),\n  commentCount: post.comments.observeCount()\n}))\n")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Starting from the second argument, ",(0,a.kt)("inlineCode",{parentName:"li"},"({ post })")," are the input props for the component. Here, we receive ",(0,a.kt)("inlineCode",{parentName:"li"},"post")," prop with a ",(0,a.kt)("inlineCode",{parentName:"li"},"Post")," object."),(0,a.kt)("li",{parentName:"ol"},"These:",(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-js"},"({\n  post: post.observe(),\n  commentCount: post.comments.observeCount()\n})\n")),"are the enhanced props we inject. The keys are props' names, and values are ",(0,a.kt)("inlineCode",{parentName:"li"},"Observable")," objects. Here, we override the ",(0,a.kt)("inlineCode",{parentName:"li"},"post")," prop with an observable version, and create a new ",(0,a.kt)("inlineCode",{parentName:"li"},"commentCount")," prop."),(0,a.kt)("li",{parentName:"ol"},"The first argument: ",(0,a.kt)("inlineCode",{parentName:"li"},"['post']")," is a list of props that trigger observation restart. So if a different ",(0,a.kt)("inlineCode",{parentName:"li"},"post")," is passed, that new post will be observed. If you pass ",(0,a.kt)("inlineCode",{parentName:"li"},"[]"),", the rendered Post will not change. You can pass multiple prop names if any of them should cause observation to re-start. Think of it the same way as the ",(0,a.kt)("inlineCode",{parentName:"li"},"deps")," argument you pass to ",(0,a.kt)("inlineCode",{parentName:"li"},"useEffect")," hook."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Rule of thumb"),": If you want to use a prop in the second arg function, pass its name in the first arg array")),(0,a.kt)("h2",{id:"advanced"},"Advanced"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"findAndObserve"),". If you have, say, a post ID from your Router (URL in the browser), you can use:",(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-js"},"withObservables(['postId'], ({ postId, database }) => ({\n  post: database.get('posts').findAndObserve(postId)\n}))\n"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"RxJS transformations"),". The values returned by ",(0,a.kt)("inlineCode",{parentName:"li"},"Model.observe()"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"Query.observe()"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"Relation.observe()")," are ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/ReactiveX/rxjs"},"RxJS Observables"),". You can use standard transforms like mapping, filtering, throttling, startWith to change when and how the component is re-rendered."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Custom Observables"),". ",(0,a.kt)("inlineCode",{parentName:"li"},"withObservables")," is a general-purpose HOC for Observables, not just Watermelon. You can create new props from any ",(0,a.kt)("inlineCode",{parentName:"li"},"Observable"),".")),(0,a.kt)("h3",{id:"advanced-observing-sorted-lists"},"Advanced: observing sorted lists"),(0,a.kt)("p",null,"If you have a list that's dynamically sorted (e.g. sort comments by number of likes), use ",(0,a.kt)("inlineCode",{parentName:"p"},"Query.observeWithColumns")," to ensure the list is re-rendered when its order changes:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"// This is a function that sorts an array of comments according to its `likes` field\n// I'm using `ramda` functions for this example, but you can do sorting however you like\nconst sortComments = sortWith([\n  descend(prop('likes'))\n])\n\nconst CommentList = ({ comments }) => (\n  <div>\n    {sortComments(comments).map(comment =>\n      <EnhancedComment key={comment.id} comment={comment} />\n    )}\n  </div>\n)\n\nconst enhance = withObservables(['post'], ({ post }) => ({\n  comments: post.comments.observeWithColumns(['likes'])\n}))\n\nconst EnhancedCommentList = enhance(CommentList)\n")),(0,a.kt)("p",null,"If you inject ",(0,a.kt)("inlineCode",{parentName:"p"},"post.comments.observe()")," into the component, the list will not re-render to change its order, only if comments are added or removed. Instead, use ",(0,a.kt)("inlineCode",{parentName:"p"},"query.observeWithColumns()")," with an array of ",(0,a.kt)("a",{parentName:"p",href:"/docs/Schema"},(0,a.kt)("strong",{parentName:"a"},"column names"))," you use for sorting to re-render whenever a record on the list has any of those fields changed."),(0,a.kt)("h3",{id:"advanced-observing-2nd-level-relations"},"Advanced: observing 2nd level relations"),(0,a.kt)("p",null,"If you have 2nd level relations, like author's ",(0,a.kt)("inlineCode",{parentName:"p"},"Contact")," info, and want to connect it to a component as well, you cannot simply use ",(0,a.kt)("inlineCode",{parentName:"p"},"post.author.contact.observe()")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"withObservables"),". Remember, ",(0,a.kt)("inlineCode",{parentName:"p"},"post.author")," is not a ",(0,a.kt)("inlineCode",{parentName:"p"},"User")," object, but a ",(0,a.kt)("inlineCode",{parentName:"p"},"Relation")," that has to be asynchronously fetched."),(0,a.kt)("p",null,"Before accessing and observing the ",(0,a.kt)("inlineCode",{parentName:"p"},"Contact")," relation, you need to resolve the ",(0,a.kt)("inlineCode",{parentName:"p"},"author")," itself. Here is the simplest way to do it:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import { compose } from 'recompose'\n\nconst enhance = compose(\n  withObservables(['post'], ({ post }) => ({\n    post,\n    author: post.author,\n  })),\n  withObservables(['author'], ({ author }) => ({\n    contact: author.contact,\n  })),\n)\n\nconst EnhancedPost = enhance(PostComponent);\n")),(0,a.kt)("p",null,"This is using a ",(0,a.kt)("inlineCode",{parentName:"p"},"compose")," function from ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/acdlite/recompose"},(0,a.kt)("inlineCode",{parentName:"a"},"recompose")),". If you're not familiar with function composition, read the ",(0,a.kt)("inlineCode",{parentName:"p"},"enhance")," function from top to bottom:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"first, the PostComponent is enhanced by changing the incoming ",(0,a.kt)("inlineCode",{parentName:"li"},"post")," prop into its observable version, and by adding a new ",(0,a.kt)("inlineCode",{parentName:"li"},"author")," prop that will contain the fetched contents of ",(0,a.kt)("inlineCode",{parentName:"li"},"post.author")),(0,a.kt)("li",{parentName:"ul"},"then, the enhanced component is enhanced once again, by adding a ",(0,a.kt)("inlineCode",{parentName:"li"},"contact")," prop containing the fetched contents of ",(0,a.kt)("inlineCode",{parentName:"li"},"author.contact"),".")),(0,a.kt)("h4",{id:"alternative-method-of-observing-2nd-level-relations"},"Alternative method of observing 2nd level relations"),(0,a.kt)("p",null,"If you are familiar with ",(0,a.kt)("inlineCode",{parentName:"p"},"rxjs"),", another way to achieve the same result is using ",(0,a.kt)("inlineCode",{parentName:"p"},"switchMap")," operator:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import { switchMap } from 'rxjs/operators'\n\nconst enhance = withObservables(['post'], ({post}) => ({\n  post: post,\n  author: post.author,\n  contact: post.author.observe().pipe(switchMap(author => author.contact.observe()))\n}))\n\nconst EnhancedPost = enhance(PostComponent)\n")),(0,a.kt)("p",null,"Now ",(0,a.kt)("inlineCode",{parentName:"p"},"PostComponent")," will have ",(0,a.kt)("inlineCode",{parentName:"p"},"Post"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Author")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Contact")," props."),(0,a.kt)("h4",{id:"2nd-level-optional-relations"},"2nd level optional relations"),(0,a.kt)("p",null,"If you have an optional relation between ",(0,a.kt)("inlineCode",{parentName:"p"},"Post")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Author"),", the enhanced component might receive ",(0,a.kt)("inlineCode",{parentName:"p"},"null")," as ",(0,a.kt)("inlineCode",{parentName:"p"},"author")," prop. As you must always return an observable for the ",(0,a.kt)("inlineCode",{parentName:"p"},"contact")," prop, you can use ",(0,a.kt)("inlineCode",{parentName:"p"},"rxjs"),"'s ",(0,a.kt)("inlineCode",{parentName:"p"},"of")," function to create a default or empty ",(0,a.kt)("inlineCode",{parentName:"p"},"Contact")," prop:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import { of as of$ } from 'rxjs'\nimport { compose } from 'recompose'\n\nconst enhance = compose(\n  withObservables(['post'], ({ post }) => ({\n    post,\n    author: post.author,\n  })),\n  withObservables(['author'], ({ author }) => ({\n    contact: author ? author.contact.observe() : of$(null),\n  })),\n)\n")),(0,a.kt)("p",null,"With the ",(0,a.kt)("inlineCode",{parentName:"p"},"switchMap")," approach, you can do:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const enhance = withObservables(['post'], ({post}) => ({\n  post: post,\n  author: post.author,\n  contact: post.autor.observe().pipe(\n    switchMap(author => author ? autor.contact : of$(null))\n  )\n}))\n")),(0,a.kt)("h2",{id:"database-provider"},"Database Provider"),(0,a.kt)("p",null,"To prevent prop drilling you can use the Database Provider and the ",(0,a.kt)("inlineCode",{parentName:"p"},"withDatabase")," Higher-Order Component."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"import DatabaseProvider from '@nozbe/watermelondb/DatabaseProvider'\n\n// ...\n\nconst database = new Database({\n  adapter,\n  modelClasses: [Blog, Post, Comment],\n})\n\nrender(\n  <DatabaseProvider database={database}>\n    <Root />\n  </DatabaseProvider>, document.getElementById('application')\n)\n\n")),(0,a.kt)("p",null,"To consume the database in your components you just wrap your component like so:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"import { withDatabase } from '@nozbe/watermelondb/DatabaseProvider'\nimport { compose } from 'recompose'\n\n// ...\n\nexport default compose(\n  withDatabase,\n  withObservables([], ({ database }) => ({\n    blogs: database.get('blogs').query(),\n  }),\n)(BlogList)\n\n")),(0,a.kt)("p",null,"The database prop in the ",(0,a.kt)("inlineCode",{parentName:"p"},"withObservables")," Higher-Order Component is provided by the database provider."),(0,a.kt)("h3",{id:"usedatabase"},(0,a.kt)("inlineCode",{parentName:"h3"},"useDatabase")),(0,a.kt)("p",null,"You can also consume ",(0,a.kt)("inlineCode",{parentName:"p"},"Database")," object using React Hooks syntax:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import { useDatabase } from '@nozbe/watermelondb/hooks'\n\nconst Component = () => {\n   const database = useDatabase()\n}\n")),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"next-steps"},"Next steps"),(0,a.kt)("p",null,"\u27a1\ufe0f Next, learn more about ",(0,a.kt)("a",{parentName:"p",href:"/docs/Query"},(0,a.kt)("strong",{parentName:"a"},"custom Queries"))))}c.isMDXComponent=!0}}]);