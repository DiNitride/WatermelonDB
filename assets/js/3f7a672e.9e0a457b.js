"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[4778],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=d(n),u=o,h=c["".concat(l,".").concat(u)]||c[u]||m[u]||r;return n?a.createElement(h,i(i({ref:t},p),{},{components:n})):a.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:o,i[1]=s;for(var d=2;d<r;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5015:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var a=n(7462),o=(n(7294),n(3905));const r={},i="Advanced Fields",s={unversionedId:"docs/Advanced/AdvancedFields",id:"docs/Advanced/AdvancedFields",title:"Advanced Fields",description:"@json",source:"@site/docs/docs/Advanced/AdvancedFields.md",sourceDirName:"docs/Advanced",slug:"/docs/Advanced/AdvancedFields",permalink:"/docs/Advanced/AdvancedFields",draft:!1,editUrl:"https://github.com/nozbe/WatermelonDB/edit/master/docs-website/docs/docs/Advanced/AdvancedFields.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Automatic create/update tracking",permalink:"/docs/Advanced/CreateUpdateTracking"},next:{title:"Flow",permalink:"/docs/Advanced/Flow"}},l={},d=[{value:"<code>@json</code>",id:"json",level:2},{value:"<code>@nochange</code>",id:"nochange",level:2},{value:"<code>@readonly</code>",id:"readonly",level:3},{value:"Custom observable fields",id:"custom-observable-fields",level:2}],p={toc:d};function c(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"advanced-fields"},"Advanced Fields"),(0,o.kt)("h2",{id:"json"},(0,o.kt)("inlineCode",{parentName:"h2"},"@json")),(0,o.kt)("p",null,"If you have a lot of metadata about a record (say, an object with many keys, or an array of values), you can use a ",(0,o.kt)("inlineCode",{parentName:"p"},"@json")," field to contain that information in a single string column (serialized to JSON) instead of adding multiple columns or a relation to another table."),(0,o.kt)("p",null,"\u26a0\ufe0f This is an advanced feature that comes with downsides \u2014 make sure you really need it"),(0,o.kt)("p",null,"First, add a string column to ",(0,o.kt)("a",{parentName:"p",href:"/docs/Schema"},"the schema"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"tableSchema({\n  name: 'comments',\n  columns: [\n    { name: 'reactions', type: 'string' }, // You can add isOptional: true, if appropriate\n  ],\n})\n")),(0,o.kt)("p",null,"Then in the Model definition:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import { json } from '@nozbe/watermelondb/decorators'\n\nclass Comment extends Model {\n  // ...\n  @json('reactions', sanitizeReactions) reactions\n}\n")),(0,o.kt)("p",null,"Now you can set complex JSON values to a field:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"comment.update(() => {\n  comment.reactions = ['up', 'down', 'down']\n})\n")),(0,o.kt)("p",null,"As the second argument, pass a ",(0,o.kt)("strong",{parentName:"p"},"sanitizer function"),". This is a function that receives whatever ",(0,o.kt)("inlineCode",{parentName:"p"},"JSON.parse()")," returns for the serialized JSON, and returns whatever type you expect in your app. In other words, it turns raw, dirty, untrusted data (that might be missing, or malformed by a bug in previous version of the app) into trusted format."),(0,o.kt)("p",null,"The sanitizer might also receive ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," if the column is nullable, or ",(0,o.kt)("inlineCode",{parentName:"p"},"undefined")," if the field doesn't contain valid JSON."),(0,o.kt)("p",null,"For example, if you need the field to be an array of strings, you can ensure it like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const sanitizeReactions = rawReactions => {\n  return Array.isArray(rawReactions) ? rawReactions.map(String) : []\n}\n")),(0,o.kt)("p",null,"If you don't want to sanitize JSON, pass an identity function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const sanitizeReactions = json => json\n")),(0,o.kt)("p",null,"The sanitizer function takes an optional second argument, which is a reference to the model. This is useful is your sanitization logic depends on the other fields in the model."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Warning about JSON fields"),":"),(0,o.kt)("p",null,"JSON fields go against relational, lazy nature of Watermelon, because ",(0,o.kt)("strong",{parentName:"p"},"you can't query or count by the contents of JSON fields"),". If you need or might need in the future to query records by some piece of data, don't use JSON."),(0,o.kt)("p",null,"Only use JSON fields when you need the flexibility of complex freeform data, or the speed of having metadata without querying another table, and you are sure that you won't need to query by those metadata."),(0,o.kt)("h2",{id:"nochange"},(0,o.kt)("inlineCode",{parentName:"h2"},"@nochange")),(0,o.kt)("p",null,"For extra protection, you can mark fields as ",(0,o.kt)("inlineCode",{parentName:"p"},"@nochange")," to ensure they can't be modified. Always put ",(0,o.kt)("inlineCode",{parentName:"p"},"@nochange")," before ",(0,o.kt)("inlineCode",{parentName:"p"},"@field")," / ",(0,o.kt)("inlineCode",{parentName:"p"},"@date")," / ",(0,o.kt)("inlineCode",{parentName:"p"},"@text")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import { field, nochange } from '@nozbe/watermelondb/decorators'\n\nclass User extends Model {\n  // ...\n  @nochange @field('is_owner') isOwner\n}\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"user.isOwner")," can only be set in the ",(0,o.kt)("inlineCode",{parentName:"p"},"collection.create()")," block, but will throw an error if you try to set a new value in ",(0,o.kt)("inlineCode",{parentName:"p"},"user.update()")," block."),(0,o.kt)("h3",{id:"readonly"},(0,o.kt)("inlineCode",{parentName:"h3"},"@readonly")),(0,o.kt)("p",null,"Similar to ",(0,o.kt)("inlineCode",{parentName:"p"},"@nochange"),", you can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"@readonly")," decorator to ensure a field cannot be set at all. Use this for ",(0,o.kt)("a",{parentName:"p",href:"/docs/Advanced/CreateUpdateTracking"},"create/update tracking"),", but it might also be useful if you use Watermelon with a ",(0,o.kt)("a",{parentName:"p",href:"/docs/Sync/Intro"},"Sync engine")," and a field can only be set by the server."),(0,o.kt)("h2",{id:"custom-observable-fields"},"Custom observable fields"),(0,o.kt)("p",null,"You're in advanced ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/ReactiveX/rxjs"},"RxJS")," territory now! You have been warned."),(0,o.kt)("p",null,'Say, you have a Post model that has many Comments. And a Post is considered to be "popular" if it has more than 10 comments.'),(0,o.kt)("p",null,'You can add a "popular" badge to a Post component in two ways.'),(0,o.kt)("p",null,"One is to simply observe how many comments there are ",(0,o.kt)("a",{parentName:"p",href:"/docs/Components"},"in the component"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const enhance = withObservables(['post'], ({ post }) => ({\n  post: post.observe(),\n  commentCount: post.comments.observeCount()\n}))\n")),(0,o.kt)("p",null,"And in the ",(0,o.kt)("inlineCode",{parentName:"p"},"render")," method, if ",(0,o.kt)("inlineCode",{parentName:"p"},"props.commentCount > 10"),", show the badge."),(0,o.kt)("p",null,"Another way is to define an observable property on the Model layer, like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import { distinctUntilChanged, map as map$ } from 'rxjs/operators'\nimport { lazy } from '@nozbe/watermelondb/decorators'\n\nclass Post extends Model {\n  @lazy isPopular = this.comments.observeCount().pipe(\n    map$(comments => comments > 10),\n    distinctUntilChanged()\n  )\n}\n")),(0,o.kt)("p",null,"And then you can directly connect this to the component:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const enhance = withObservables(['post'], ({ post }) => ({\n  isPopular: post.isPopular,\n}))\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"props.isPopular")," will reflect whether or not the Post is popular. Note that this is fully observable, i.e. if the number of comments rises above/falls below the popularity threshold, the component will re-render. Let's break it down:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"this.comments.observeCount()")," - take the Observable number of comments"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"map$(comments => comments > 10)")," - transform this into an Observable of boolean (popular or not)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"distinctUntilChanged()")," - this is so that if the comment count changes, but the popularity doesn't (it's still below/above 10), components won't be unnecessarily re-rendered"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@lazy")," - also for performance (we only define this Observable once, so we can re-use it for free)")),(0,o.kt)("p",null,"Let's make this example more complicated. Say the post is ",(0,o.kt)("strong",{parentName:"p"},"always")," popular if it's marked as starred. So if ",(0,o.kt)("inlineCode",{parentName:"p"},"post.isStarred"),", then we don't have to do unnecessary work of fetching comment count:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import { of as of$ } from 'rxjs/observable/of'\nimport { distinctUntilChanged, map as map$ } from 'rxjs/operators'\nimport { lazy } from '@nozbe/watermelondb/decorators'\n\nclass Post extends Model {\n  @lazy isPopular = this.observe().pipe(\n    distinctUntilKeyChanged('isStarred'),\n    switchMap(post =>\n      post.isStarred ?\n        of$(true) :\n        this.comments.observeCount().pipe(map$(comments => comments > 10))\n    ),\n    distinctUntilChanged(),\n  )\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"this.observe()")," - if the Post changes, it might change its popularity status, so we observe it"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"this.comments.observeCount().pipe(map$(comments => comments > 10))")," - this part is the same, but we only observe it if the post is starred"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"switchMap(post => post.isStarred ? of$(true) : ...)")," - if the post is starred, we just return an Observable that emits ",(0,o.kt)("inlineCode",{parentName:"li"},"true")," and never changes."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"distinctUntilKeyChanged('isStarred')")," - for performance, so that we don't re-subscribe to comment count Observable if the post changes (only if the ",(0,o.kt)("inlineCode",{parentName:"li"},"isStarred")," field changes)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"distinctUntilChanged()")," - again, don't emit new values, if popularity doesn't change")))}c.isMDXComponent=!0}}]);