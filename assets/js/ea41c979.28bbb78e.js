"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[4941],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},l=Object.keys(e);for(o=0;o<l.length;o++)n=l[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(o=0;o<l.length;o++)n=l[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var i=o.createContext({}),m=function(e){var t=o.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=m(e.components);return o.createElement(i.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=m(n),u=a,h=d["".concat(i,".").concat(u)]||d[u]||p[u]||l;return n?o.createElement(h,r(r({ref:t},c),{},{components:n})):o.createElement(h,r({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,r=new Array(l);r[0]=u;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s[d]="string"==typeof e?e:a,r[1]=s;for(var m=2;m<l;m++)r[m]=n[m];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4858:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>r,default:()=>d,frontMatter:()=>l,metadata:()=>s,toc:()=>m});var o=n(7462),a=(n(7294),n(3905));const l={title:"Flow",hide_title:!0},r="Watermelon \u2764\ufe0f Flow",s={unversionedId:"docs/Advanced/Flow",id:"docs/Advanced/Flow",title:"Flow",description:"Watermelon was developed with Flow in mind.",source:"@site/docs/docs/Advanced/Flow.md",sourceDirName:"docs/Advanced",slug:"/docs/Advanced/Flow",permalink:"/docs/Advanced/Flow",draft:!1,editUrl:"https://github.com/nozbe/WatermelonDB/edit/master/docs-website/docs/docs/Advanced/Flow.md",tags:[],version:"current",frontMatter:{title:"Flow",hide_title:!0},sidebar:"docs",previous:{title:"Advanced Fields",permalink:"/docs/Advanced/AdvancedFields"},next:{title:"LocalStorage",permalink:"/docs/Advanced/LocalStorage"}},i={},m=[{value:"Setup",id:"setup",level:2},{value:"Tables and columns",id:"tables-and-columns",level:2},{value:"But isn&#39;t that a lot of boilerplate?",id:"but-isnt-that-a-lot-of-boilerplate",level:3},{value:"associations",id:"associations",level:3},{value:"Common types",id:"common-types",level:2}],c={toc:m};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"watermelon-\ufe0f-flow"},"Watermelon \u2764\ufe0f Flow"),(0,a.kt)("p",null,"Watermelon was developed with ",(0,a.kt)("a",{parentName:"p",href:"https://flow.org"},"Flow")," in mind."),(0,a.kt)("p",null,"If you're a Flow user yourself (and we highly recommend it!), here's some things you need to keep in mind:"),(0,a.kt)("h2",{id:"setup"},"Setup"),(0,a.kt)("p",null,"Add this to your ",(0,a.kt)("inlineCode",{parentName:"p"},".flowconfig")," file so that Flow can see Watermelon's types."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ini"},"[declarations]\n<PROJECT_ROOT>/node_modules/@nozbe/watermelondb/.*\n\n[options]\n\nmodule.name_mapper='^@nozbe/watermelondb\\(.*\\)$' -> '<PROJECT_ROOT>/node_modules/@nozbe/watermelondb/src\\1'\n")),(0,a.kt)("p",null,"Note that this won't work if you put the entire ",(0,a.kt)("inlineCode",{parentName:"p"},"node_modules/")," folder under the ",(0,a.kt)("inlineCode",{parentName:"p"},"[ignore]")," section. In that case, change it to only ignore the specific node modules that throw errors in your app, so that Flow can scan Watermelon files."),(0,a.kt)("h2",{id:"tables-and-columns"},"Tables and columns"),(0,a.kt)("p",null,"Table and column names are ",(0,a.kt)("strong",{parentName:"p"},"opaque types")," in Flow."),(0,a.kt)("p",null,"So if you try to use simple strings, like so:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"class Comment extends Model {\n  static table = 'comments'\n\n  @text('body') body\n}\n")),(0,a.kt)("p",null,"You'll get errors, because you're passing ",(0,a.kt)("inlineCode",{parentName:"p"},"'comments'")," (a ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),") where ",(0,a.kt)("inlineCode",{parentName:"p"},"TableName<Comment>")," is expected, and ",(0,a.kt)("inlineCode",{parentName:"p"},"'body'")," (again, a ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),") where ",(0,a.kt)("inlineCode",{parentName:"p"},"ColumnName")," is expected."),(0,a.kt)("p",null,"When using Watermelon with Flow, you must pre-define all your table and column names in one place, then only use those symbols (and not strings) in all other places."),(0,a.kt)("p",null,"We recommend defining symbols like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"// File: model/schema.js\n// @flow\n\nimport { tableName, columnName, type TableName, appSchema, tableSchema } from '@nozbe/watermelondb'\nimport type Comment from './Comment.js'\n\nexport const Tables = {\n  comments: (tableName('comments'): TableName<Comment>),\n  // ...\n}\n\nexport const Columns = {\n  comments: {\n    body: columnName('body'),\n    // ...\n  }\n}\n\nexport const appSchema = appSchema({\n  version: 1,\n  tables: [\n    tableSchema({\n      name: Tables.comments,\n      columns: [\n        { name: Columns.comments.body, type: 'string' },\n      ],\n    }),\n    // ...\n  ]\n})\n")),(0,a.kt)("p",null,"And then using them like so:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"// File: model/Comment.js\n// @flow\n\nimport { Model } from '@nozbe/watermelondb'\nimport { text } from '@nozbe/watermelondb/decorators'\n\nimport { Tables, Columns } from './schema.js'\n\nconst Column = Columns.comments\n\nexport default class Comment extends Model {\n  static table = Tables.comments\n\n  @text(Column.body) body: string\n}\n")),(0,a.kt)("h3",{id:"but-isnt-that-a-lot-of-boilerplate"},"But isn't that a lot of boilerplate?"),(0,a.kt)("p",null,"Yes, it looks more boilerplate'y than the non-Flow examples, however:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"you're protected from typos \u2014\xa0strings are defined once"),(0,a.kt)("li",{parentName:"ul"},"easier refactoring \u2014 you only change column name in one place"),(0,a.kt)("li",{parentName:"ul"},"no orphan columns or tables \u2014 no way to accidentally refer to a column or table that was removed from the schema"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"TableName")," is typed with the model class it refers to, which allows Flow to find other mistakes in your code")),(0,a.kt)("p",null,"In general, we find that untyped string constants lead to bugs, and defining typed constants is a good practice."),(0,a.kt)("h3",{id:"associations"},"associations"),(0,a.kt)("p",null,"When using Flow, you define model associations like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import { Model, associations } from '@nozbe/watermelondb'\nimport { Tables, Columns } from './schema.js'\n\nconst Column = Columns.posts\n\nclass Post extends Model {\n  static table = Tables.posts\n  static associations = associations(\n    [Tables.comments, { type: 'has_many', foreignKey: Columns.comments.postId }],\n    [Tables.users, { type: 'belongs_to', key: Column.authorId }],\n  )\n}\n")),(0,a.kt)("h2",{id:"common-types"},"Common types"),(0,a.kt)("p",null,"Many types are tagged with the model class the type refers to:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"TableName<Post> // a table name referring to posts\nCollection<Post> // the Collection for posts\nRelation<Comment> // a relation that can fetch a Comment\nRelation<?Comment> // a relation that can fetch a Comment or `null`\nQuery<Comment> // a query that can fetch many Comments\n")),(0,a.kt)("p",null,"Always mark the type of model fields. Remember to include ",(0,a.kt)("inlineCode",{parentName:"p"},"?")," if the underlying table column is optional. Flow can't check if model fields match the schema or if they match the decorator's signature."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"@text(Column.body) body: string\n@date(Column.createdAt) createdAt: Date\n@date(Column.archivedAt) archivedAt: ?Date\n")),(0,a.kt)("p",null,"If you need to refer to an ID of a record, always use the ",(0,a.kt)("inlineCode",{parentName:"p"},"RecordId")," type alias, not ",(0,a.kt)("inlineCode",{parentName:"p"},"string")," (they're the same, but the former is self-documenting)."),(0,a.kt)("p",null,"If you ever access the record's raw data (DON'T do that unless you ",(0,a.kt)("em",{parentName:"p"},"really")," know what you're doing), use ",(0,a.kt)("inlineCode",{parentName:"p"},"DirtyRaw")," to refer to raw data from external sources (database, server), and ",(0,a.kt)("inlineCode",{parentName:"p"},"RawRecord")," after it was passed through ",(0,a.kt)("inlineCode",{parentName:"p"},"sanitizedRaw"),"."))}d.isMDXComponent=!0}}]);