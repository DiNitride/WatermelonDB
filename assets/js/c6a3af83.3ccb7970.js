"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[4480],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),p=d(n),m=i,h=p["".concat(s,".").concat(m)]||p[m]||u[m]||r;return n?a.createElement(h,l(l({ref:t},c),{},{components:n})):a.createElement(h,l({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[p]="string"==typeof e?e:i,l[1]=o;for(var d=2;d<r;d++)l[d]=n[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2054:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var a=n(7462),i=(n(7294),n(3905));const r={title:"Backend",hide_title:!0},l=void 0,o={unversionedId:"docs/Sync/Backend",id:"docs/Sync/Backend",title:"Backend",description:"Implementing your Sync backend",source:"@site/docs/docs/Sync/Backend.md",sourceDirName:"docs/Sync",slug:"/docs/Sync/Backend",permalink:"/docs/Sync/Backend",draft:!1,editUrl:"https://github.com/nozbe/WatermelonDB/edit/master/docs-website/docs/docs/Sync/Backend.md",tags:[],version:"current",frontMatter:{title:"Backend",hide_title:!0},sidebar:"docs",previous:{title:"Frontend",permalink:"/docs/Sync/Frontend"},next:{title:"Limitations",permalink:"/docs/Sync/Limitations"}},s={},d=[{value:"Implementing your Sync backend",id:"implementing-your-sync-backend",level:2},{value:"Understanding <code>changes</code> objects",id:"understanding-changes-objects",level:3},{value:"Implementing pull endpoint",id:"implementing-pull-endpoint",level:3},{value:"Implementing push endpoint",id:"implementing-push-endpoint",level:3},{value:"Tips on implementing server-side changes tracking",id:"tips-on-implementing-server-side-changes-tracking",level:2},{value:"Existing Backend Implementations",id:"existing-backend-implementations",level:2}],c={toc:d};function p(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"implementing-your-sync-backend"},"Implementing your Sync backend"),(0,i.kt)("h3",{id:"understanding-changes-objects"},"Understanding ",(0,i.kt)("inlineCode",{parentName:"h3"},"changes")," objects"),(0,i.kt)("p",null,"Synchronized changes (received by the app in ",(0,i.kt)("inlineCode",{parentName:"p"},"pullChanges")," and sent to the backend in ",(0,i.kt)("inlineCode",{parentName:"p"},"pushChanges"),") are represented as an object with ",(0,i.kt)("em",{parentName:"p"},"raw records"),". Those only use raw table and column names, and raw values (strings/numbers/booleans) \u2014 the same as in ",(0,i.kt)("a",{parentName:"p",href:"/docs/Schema"},"Schema"),"."),(0,i.kt)("p",null,"Deleted objects are always only represented by their IDs."),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"{\n  projects: {\n    created: [\n      { id: 'aaaa', name: 'Foo', is_favorite: true },\n      { id: 'bbbb', name: 'Bar', is_favorite: false },\n    ],\n    updated: [\n      { id: 'ccc', name: 'Baz', is_favorite: true },\n    ],\n    deleted: ['ddd'],\n  },\n  tasks: {\n    created: [],\n    updated: [\n      { id: 'tttt', name: 'Buy eggs' },\n    ],\n    deleted: [],\n  },\n  ...\n}\n")),(0,i.kt)("p",null,"Again, notice the properties returned have the format defined in the ",(0,i.kt)("a",{parentName:"p",href:"/docs/Schema"},"Schema")," (e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"is_favorite"),", not ",(0,i.kt)("inlineCode",{parentName:"p"},"isFavorite"),")."),(0,i.kt)("p",null,"Valid changes objects MUST conform to this shape:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"Changes = {\n  [table_name: string]: {\n    created: RawRecord[],\n    updated: RawRecord[],\n    deleted: string[],\n  }\n}\n")),(0,i.kt)("h3",{id:"implementing-pull-endpoint"},"Implementing pull endpoint"),(0,i.kt)("p",null,"Expected parameters:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"{\n  lastPulledAt: Timestamp,\n  schemaVersion: int,\n  migration: null | { from: int, tables: string[], columns: { table: string, columns: string[] }[] }\n}\n")),(0,i.kt)("p",null,"Expected response:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"{ changes: Changes, timestamp: Timestamp }\n")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The pull endpoint SHOULD take parameters and return a response matching the shape specified above.\nThis shape MAY be different if negotiated with the frontend (however, frontend-side ",(0,i.kt)("inlineCode",{parentName:"li"},"pullChanges()")," MUST conform to this)"),(0,i.kt)("li",{parentName:"ol"},"The pull endpoint MUST return all record changes in all collections since ",(0,i.kt)("inlineCode",{parentName:"li"},"lastPulledAt"),", specifically:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"all records that were created on the server since ",(0,i.kt)("inlineCode",{parentName:"li"},"lastPulledAt")),(0,i.kt)("li",{parentName:"ul"},"all records that were updated on the server since ",(0,i.kt)("inlineCode",{parentName:"li"},"lastPulledAt")),(0,i.kt)("li",{parentName:"ul"},"IDs of all records that were deleted on the server since ",(0,i.kt)("inlineCode",{parentName:"li"},"lastPulledAt")),(0,i.kt)("li",{parentName:"ul"},"record IDs MUST NOT be duplicated"))),(0,i.kt)("li",{parentName:"ol"},"If ",(0,i.kt)("inlineCode",{parentName:"li"},"lastPulledAt")," is null or 0, you MUST return all accessible records (first sync)"),(0,i.kt)("li",{parentName:"ol"},"The timestamp returned by the server MUST be a value that, if passed again to ",(0,i.kt)("inlineCode",{parentName:"li"},"pullChanges()")," as ",(0,i.kt)("inlineCode",{parentName:"li"},"lastPulledAt"),", will return all changes that happened since this moment."),(0,i.kt)("li",{parentName:"ol"},"The pull endpoint MUST provide a consistent view of changes since ",(0,i.kt)("inlineCode",{parentName:"li"},"lastPulledAt"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"You should perform all queries synchronously or in a write lock to ensure that returned changes are consistent"),(0,i.kt)("li",{parentName:"ul"},"You should also mark the current server time synchronously with the queries"),(0,i.kt)("li",{parentName:"ul"},"This is to ensure that no changes are made to the database while you're fetching changes (otherwise some records would never be returned in a pull query)"),(0,i.kt)("li",{parentName:"ul"},"If it's absolutely not possible to do so, and you have to query each collection separately, be sure to return a ",(0,i.kt)("inlineCode",{parentName:"li"},"lastPulledAt")," timestamp marked BEFORE querying starts. You still risk inconsistent responses (that may break app's consistency assumptions), but the next pull will fetch whatever changes occured during previous pull."),(0,i.kt)("li",{parentName:"ul"},"An alternative solution is to check for the newest change before and after all queries are made, and if there's been a change during the pull, return an error code, or retry."))),(0,i.kt)("li",{parentName:"ol"},"If ",(0,i.kt)("inlineCode",{parentName:"li"},"migration")," is not null, you MUST include records needed to get a consistent view after a local database migration",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Specifically, you MUST include all records in tables that were added to the local database between the last user sync and ",(0,i.kt)("inlineCode",{parentName:"li"},"schemaVersion")),(0,i.kt)("li",{parentName:"ul"},"For all columns that were added to the local app database between the last sync and ",(0,i.kt)("inlineCode",{parentName:"li"},"schemaVersion"),", you MUST include all records for which the added column has a value other than the default value (",(0,i.kt)("inlineCode",{parentName:"li"},"0"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"''"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"false"),", or ",(0,i.kt)("inlineCode",{parentName:"li"},"null")," depending on column type and nullability)"),(0,i.kt)("li",{parentName:"ul"},"You can determine what schema changes were made to the local app in two ways:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"You can compare ",(0,i.kt)("inlineCode",{parentName:"li"},"migration.from")," (local schema version at the time of the last sync) and ",(0,i.kt)("inlineCode",{parentName:"li"},"schemaVersion")," (current local schema version). This requires you to negotiate with the frontend what schema changes are made at which schema versions, but gives you more control"),(0,i.kt)("li",{parentName:"ul"},"Or you can ignore ",(0,i.kt)("inlineCode",{parentName:"li"},"migration.from")," and only look at ",(0,i.kt)("inlineCode",{parentName:"li"},"migration.tables")," (which indicates which tables were added to the local database since the last sync) and ",(0,i.kt)("inlineCode",{parentName:"li"},"migration.columns")," (which indicates which columns were added to the local database to which tables since last sync)."),(0,i.kt)("li",{parentName:"ul"},"If you use ",(0,i.kt)("inlineCode",{parentName:"li"},"migration.tables")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"migration.columns"),", you MUST whitelist values a client can request. Take care not to leak any internal fields to the client."))))),(0,i.kt)("li",{parentName:"ol"},"Returned raw records MUST match your app's ",(0,i.kt)("a",{parentName:"li",href:"/docs/Schema"},"Schema")),(0,i.kt)("li",{parentName:"ol"},"Returned raw records MUST NOT not contain special ",(0,i.kt)("inlineCode",{parentName:"li"},"_status"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"_changed")," fields."),(0,i.kt)("li",{parentName:"ol"},"Returned raw records MAY contain fields (columns) that are not yet present in the local app (at ",(0,i.kt)("inlineCode",{parentName:"li"},"schemaVersion")," -- but added in a later version). They will be safely ignored."),(0,i.kt)("li",{parentName:"ol"},"Returned raw records MUST NOT contain arbitrary column names, as they may be unsafe (e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"__proto__")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"constructor"),"). You should whitelist acceptable column names."),(0,i.kt)("li",{parentName:"ol"},"Returned record IDs MUST only contain safe characters",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Default WatermelonDB IDs conform to ",(0,i.kt)("inlineCode",{parentName:"li"},"/^[a-zA-Z0-9]{16}$/")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_-.")," are also allowed if you override default ID generator, but ",(0,i.kt)("inlineCode",{parentName:"li"},"'\"\\/$")," are unsafe"))),(0,i.kt)("li",{parentName:"ol"},"Changes SHOULD NOT contain collections that are not yet present in the local app (at ",(0,i.kt)("inlineCode",{parentName:"li"},"schemaVersion"),"). They will, however, be safely ignored.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"NOTE: This is true for WatermelonDB v0.17 and above. If you support clients using earlier versions, you MUST NOT return collections not known by them."))),(0,i.kt)("li",{parentName:"ol"},"Changes MUST NOT contain collections with arbitrary names, as they may be unsafe. You should whitelist acceptable collection names.")),(0,i.kt)("h3",{id:"implementing-push-endpoint"},"Implementing push endpoint"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The push endpoint MUST apply local changes (passed as a ",(0,i.kt)("inlineCode",{parentName:"li"},"changes")," object) to the database. Specifically:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"create new records as specified by the changes object"),(0,i.kt)("li",{parentName:"ul"},"update existing records as specified by the changes object"),(0,i.kt)("li",{parentName:"ul"},"delete records by the specified IDs"))),(0,i.kt)("li",{parentName:"ol"},"If the ",(0,i.kt)("inlineCode",{parentName:"li"},"changes")," object contains a new record with an ID that already exists, you MUST update it, and MUST NOT return an error code.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"(This happens if previous push succeeded on the backend, but not on frontend)"))),(0,i.kt)("li",{parentName:"ol"},"If the ",(0,i.kt)("inlineCode",{parentName:"li"},"changes")," object contains an update to a record that does not exist, then:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"If you can determine that this record no longer exists because it was deleted, you SHOULD return an error code (to force frontend to pull the information about this deleted ID)"),(0,i.kt)("li",{parentName:"ul"},"Otherwise, you MUST create it, and MUST NOT return an error code. (This scenario should not happen, but in case of frontend or backend bugs, it would keep sync from ever succeeding.)"))),(0,i.kt)("li",{parentName:"ol"},"If the ",(0,i.kt)("inlineCode",{parentName:"li"},"changes")," object contains a record to delete that doesn't exist, you MUST ignore it and MUST NOT return an error code",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"(This may happen if previous push succeeded on the backend, but not on frontend, or if another user deleted this record in between user's pull and push calls)"))),(0,i.kt)("li",{parentName:"ol"},"If the ",(0,i.kt)("inlineCode",{parentName:"li"},"changes")," object contains a record that has been modified on the server after ",(0,i.kt)("inlineCode",{parentName:"li"},"lastPulledAt"),", you MUST abort push and return an error code",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"This scenario means that there's a conflict, and record was updated remotely between user's pull and push calls. Returning an error forces frontend to call pull endpoint again to resolve the conflict"))),(0,i.kt)("li",{parentName:"ol"},"If application of all local changes succeeds, the endpoint MUST return a success status code."),(0,i.kt)("li",{parentName:"ol"},"The push endpoint MUST be fully transactional. If there is an error, all local changes MUST be reverted on the server, and en error code MUST be returned."),(0,i.kt)("li",{parentName:"ol"},"You MUST ignore ",(0,i.kt)("inlineCode",{parentName:"li"},"_status")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"_changed")," fields contained in records in ",(0,i.kt)("inlineCode",{parentName:"li"},"changes")," object"),(0,i.kt)("li",{parentName:"ol"},"You SHOULD validate data passed to the endpoint. In particular, collection and column names ought to be whitelisted, as well as ID format \u2014 and of course any application-specific invariants, such as permissions to access and modify records"),(0,i.kt)("li",{parentName:"ol"},"You SHOULD sanitize record fields passed to the endpoint. If there's something slightly wrong with the contents (but not shape) of the data (e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"user.role")," should be ",(0,i.kt)("inlineCode",{parentName:"li"},"owner"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"admin"),", or ",(0,i.kt)("inlineCode",{parentName:"li"},"member"),", but user sent empty string or ",(0,i.kt)("inlineCode",{parentName:"li"},"abcdef"),'), you SHOULD NOT send an error code. Instead, prefer to "fix" errors (sanitize to correct format).',(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Rationale: Synchronization should be reliable, and should not fail other than transiently, or for serious programming errors. Otherwise, the user will have a permanently unsyncable app, and may have to log out/delete it and lose unsynced data. You don't want a bug 5 versions ago to create a persistently failing sync."))),(0,i.kt)("li",{parentName:"ol"},"You SHOULD delete all descendants of deleted records",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Frontend should ask the push endpoint to do so as well, but if it's buggy, you may end up with permanent orphans")))),(0,i.kt)("h2",{id:"tips-on-implementing-server-side-changes-tracking"},"Tips on implementing server-side changes tracking"),(0,i.kt)("p",null,"If you're wondering how to ",(0,i.kt)("em",{parentName:"p"},"actually")," implement consistent pulling of all changes since the last pull, or how to detect that a record being pushed by the user changed after ",(0,i.kt)("inlineCode",{parentName:"p"},"lastPulledAt"),", here's what we recommend:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Add a ",(0,i.kt)("inlineCode",{parentName:"li"},"last_modified")," field to all your server database tables, and bump it to ",(0,i.kt)("inlineCode",{parentName:"li"},"NOW()")," every time you create or update a record."),(0,i.kt)("li",{parentName:"ul"},"This way, when you want to get all changes since ",(0,i.kt)("inlineCode",{parentName:"li"},"lastPulledAt"),", you query records whose ",(0,i.kt)("inlineCode",{parentName:"li"},"last_modified > lastPulledAt"),"."),(0,i.kt)("li",{parentName:"ul"},"The timestamp should be at least millisecond resolution, and you should add (for extra safety) a MySQL/PostgreSQL procedure that will ensure ",(0,i.kt)("inlineCode",{parentName:"li"},"last_modified")," uniqueness and monotonicity",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Specificaly, check that there is no record with a ",(0,i.kt)("inlineCode",{parentName:"li"},"last_modified")," equal to or greater than ",(0,i.kt)("inlineCode",{parentName:"li"},"NOW()"),", and if there is, increment the new timestamp by 1 (or however much you need to ensure it's the greatest number)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Kinto/kinto/blob/814c30c5dd745717b8ea50d708d9163a38d2a9ec/kinto/core/storage/postgresql/schema.sql#L64-L116"},"An example of this for PostgreSQL can be found in Kinto")),(0,i.kt)("li",{parentName:"ul"},"This protects against weird edge cases - such as records being lost due to server clock time changes (NTP time sync, leap seconds, etc.)"))),(0,i.kt)("li",{parentName:"ul"},"Of course, remember to ignore ",(0,i.kt)("inlineCode",{parentName:"li"},"last_modified")," from the user if you do it this way."),(0,i.kt)("li",{parentName:"ul"},"An alternative to using timestamps is to use an auto-incrementing counter sequence, but you must ensure that this sequence is consistent across all collections. You also leak to users the amount of traffic to your sync server (number of changes in the sequence)"),(0,i.kt)("li",{parentName:"ul"},"To distinguish between ",(0,i.kt)("inlineCode",{parentName:"li"},"created")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"updated")," records, you can also store server-side ",(0,i.kt)("inlineCode",{parentName:"li"},"server_created_at")," timestamp (if it's greater than ",(0,i.kt)("inlineCode",{parentName:"li"},"last_pulled_at")," supplied to sync, then record is to be ",(0,i.kt)("inlineCode",{parentName:"li"},"created")," on client, if less than \u2014 client already has it and it is to be ",(0,i.kt)("inlineCode",{parentName:"li"},"updated")," on client). Note that this timestamp must be consistent with last_modified \u2014 and you must not use client-created ",(0,i.kt)("inlineCode",{parentName:"li"},"created_at")," field, since you can never trust local timestamps.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Alternatively, you can send all non-deleted records as all ",(0,i.kt)("inlineCode",{parentName:"li"},"updated")," and Watermelon will do the right thing in 99% of cases (you will be slightly less protected against weird edge cases \u2014 treatment of locally deleted records is different). If you do this, pass ",(0,i.kt)("inlineCode",{parentName:"li"},"sendCreatedAsUpdated: true")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"synchronize()")," to supress warnings about records to be updated not existing locally."))),(0,i.kt)("li",{parentName:"ul"},"You do need to implement a mechanism to track when records were deleted on the server, otherwise you wouldn't know to push them",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"One possible implementation is to not fully delete records, but mark them as DELETED=true"),(0,i.kt)("li",{parentName:"ul"},"Or, you can have a ",(0,i.kt)("inlineCode",{parentName:"li"},"deleted_xxx")," table with just the record ID and timestamp (consistent with last_modified)"),(0,i.kt)("li",{parentName:"ul"},'Or, you can treat it the same way as "revoked permissions"'))),(0,i.kt)("li",{parentName:"ul"},"If you have a collaborative app with any sort of permissions, you also need to track granting and revoking of permissions the same way as changes to records",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"If permission to access records has been granted, the pull endpoint must add those records to ",(0,i.kt)("inlineCode",{parentName:"li"},"created")),(0,i.kt)("li",{parentName:"ul"},"If permission to access records has been revoked, the pull endpoint must add those records to ",(0,i.kt)("inlineCode",{parentName:"li"},"deleted")),(0,i.kt)("li",{parentName:"ul"},"Remember to also return all descendants of a record in those cases")))),(0,i.kt)("h2",{id:"existing-backend-implementations"},"Existing Backend Implementations"),(0,i.kt)("p",null,"Note that those are not maintained by WatermelonDB, and we make no endorsements about quality of these projects:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://fahri.id/posts/how-to-build-watermelondb-sync-backend-in-elixir/"},"How to Build WatermelonDB Sync Backend in Elixir")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/AliAllaf/firemelon"},"Firemelon")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/nathanheffley/laravel-watermelon"},"Laravel Watermelon"))),(0,i.kt)("p",null,"Did you make one? Please contribute a link!"))}p.isMDXComponent=!0}}]);